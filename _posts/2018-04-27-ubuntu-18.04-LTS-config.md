---
layout: post
title: Ubuntu 18.04 LTS 配置
categories: Linux
description: 主要工作环境迁移到 Ubuntu 后，进行一些必要的配置，方便使用。
keywords: Linux, Ubuntu
---

安装完 Ubuntu 18.04 LTS 后进行一些必要的配置，方便使用。

# 将你的硬件时钟设置为本地时区

```sh
sudo timedatectl set-local-rtc 1
```

# 更改源为阿里云

在 应用程序 > 软件和更新 中更改源为阿里云 mirrors.aliyun.com

# 安装aptitude

```sh
sudo apt-get install aptitude
```

# 安装vim

```sh
sudo apt-get install vim-gnome
```

vim配置

```sh
vim ~/.vimrc
```

添加

```
" *****indent*****
" ai autoindent
set autoindent
" filetype indent
filetype plugin indent on
" sw 使用每层缩进的空格数
set shiftwidth=4
" *****indent*****

" *****tab*****
" ts 编辑时一个TAB字符占多少个空格的位置
set tabstop=4
" et 是否将输入的TAB自动展开成空格。开启后要输入TAB，需要Ctrl-V<TAB>
set expandtab
" *****tab*****

" *****key mapping*****
" 快速按下fd退出insert模式
inoremap fd <esc>
" 粘贴模式开关，开启后会关闭自动缩进，避免粘贴错位
set pastetoggle=<F9>
" *****key mapping*****

" 显示行号
set number
```

# 安装git

```sh
sudo apt-get install git
```

设置name，email，push

```sh
git config --global user.name <name>
git config --global user.email <email>
git config --global push.default simple
```

使用ssh，生成公钥后在github上添加SSH keys

```sh
ssh-keygen -t rsa -C <email>
```

# 安装gnome-tweak-tool

Ubuntu 18.04 LTS 中 gnome 为默认桌面，安装优化工具可以进行高级设置

```sh
sudo apt-get install gnome-tweak-tool
```

# 安装zsh & oh-my-zsh

安装zsh

```sh
sudo apt-get install zsh
```

更改当前用户默认的shell为zsh

```sh
chsh -s $(which zsh)
```

安装oh-my-zsh

```sh
sh -c "$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"
```

修改主题为agnoster

```sh
vim ~/.zshrc

# 主题改为如下
# ZSH_THEME="agnoster"
```

安装 agnoster 主题依赖的字体 powerline ，并设置等宽字体，否则会出现乱码

```sh
# clone
git clone https://github.com/powerline/fonts.git --depth=1

# install
cd fonts
./install.sh

# clean-up a bit
cd ..
rm -rf fonts
```

打开优化工具，等宽字体设置为 Ubuntu Mono derivative Powerline Regular

注销后生效

# 开启TCP BBR拥塞控制算法

Linux kernel 4.9+ 已经支持`tcp_bbr`，ubuntu 18.04 默认使用4.15内核，可以直接开启

写入配置文件

```sh
sudo bash -c 'cat >> /etc/sysctl.conf' << EOF

net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr
EOF
```

让内核配置生效

```sh
sudo sysctl -p
```

以下两条命令的结果中都有bbr，说明内核已经开启bbr

```sh
sysctl net.ipv4.tcp_available_congestion_control
sysctl net.ipv4.tcp_congestion_control
```

以下命令看到有 `tcp_bbr`，说明bbr已启动

```sh
lsmod | grep bbr
```

我这边网络环境比较恶劣，开启bbr后大幅改善响应速度

# 全局智能代理

流量分流方案: tun2socks + shadowsocks-libev

常见透明代理方案(tcp+udp)使用ss-redir(运行在网关上，在mangle表PREROUTING链中用TPROXY转发内网udp)，但局限是无法转发网关自身的udp流量

tun2socks支持转发本地udp，适用于想要把代理部署在本地的用户

可选udp通路的丢包改善方案: UDPspeeder + udp2raw

UDPspeeder提供了FEC(前向纠错)和多倍发包方案，可以在牺牲一定带宽的前提下大大降低丢包率(准确的说是在原始丢包率的网络状况下通过发送额外的冗余包来实现恢复出原始udp包，从而避免丢包重传)

- 优点: 降低丢包率，提高稳定性
- 缺点: 浪费额外带宽(也就意味着有效带宽减少，体现为udp下载速度变慢)，引入少量延迟

udp2raw可将udp包模拟成tcp，模拟三次握手，从而绕过ISP的qos限制，本质仍是udp

DNS分流方案: overture

overture是一个DNS分流净化软件，可配置多个上游DNS，自动选择最快应答，支持缓存，支持ECS，支持本地Host配置

处理逻辑: 配置主从DNS集合，主DNS集为国内常用DNS服务提供商，本地ISP、DNSPod、AliDNS之流，从DNS一般配置一个支持ECS的DNS，主要用于查询国外域名，默认使用OpenDNS的443端口进行tcp查询。用户请求的域名如果在DomainFile中匹配，则直接使用从DNS解析。若主DNS解析得出的IP不在IPNetworkFile中，则使用从DNS解析

## ss-tun2socks

项目地址

[https://github.com/zfl9/ss-tun2socks.git](https://github.com/zfl9/ss-tun2socks.git)

由于dns我用的是overture，脚本中的chinadns和pdnsd部分可以删掉，然后再整合UDPspeeder和udp2raw进去

ss-tun2socks修改如下

```sh
#!/bin/bash

main_cfg='/etc/tun2socks/ss-tun2socks.conf'

if [ ! -e "${main_cfg}" ]; then
    echo -e "\e[37m${main_cfg}\e[0m  [\e[1;35mnot_exist\e[0m]" 1>&2
    exit 1
else
    source "${main_cfg}"
fi

function chnip_update() {
    #chnip_url="http://f.ip.cn/rt/chnroutes.txt"
    chnip_url="https://github.com/17mon/china_ip_list/raw/master/china_ip_list.txt"
    curl -4sSkL ${chnip_url} | egrep -v '^\s*$|^\s*#' > ${dns_chnroute}
    cat ${dns_chnroute} | xargs -n1 echo add chnroute > ${ipset_save_file}

    ipset -L chnroute &> /dev/null
    if [ $? -ne 0 ]; then
        ipset -N chnroute hash:net
    else
        ipset -F chnroute &> /dev/null
    fi

    ipset -R < ${ipset_save_file}
    ipset -S chnroute > ${ipset_save_file}
}

function ipts_update() {
    iptables -t mangle -F OUTPUT
    iptables -t mangle -F PREROUTING
    iptables -t mangle -F TUN2SOCKS &> /dev/null
    iptables -t mangle -X TUN2SOCKS &> /dev/null
    iptables -t nat -F PREROUTING
    iptables -t nat -F POSTROUTING

    iptables -t mangle -N TUN2SOCKS
    iptables -t mangle -A TUN2SOCKS -d 0/8 -j RETURN
    iptables -t mangle -A TUN2SOCKS -d 10/8 -j RETURN
    iptables -t mangle -A TUN2SOCKS -d 127/8 -j RETURN
    iptables -t mangle -A TUN2SOCKS -d 169.254/16 -j RETURN
    iptables -t mangle -A TUN2SOCKS -d 172.16/12 -j RETURN
    iptables -t mangle -A TUN2SOCKS -d 192.168/16 -j RETURN
    iptables -t mangle -A TUN2SOCKS -d 224/4 -j RETURN
    iptables -t mangle -A TUN2SOCKS -d 240/4 -j RETURN
    #iptables -t mangle -A TUN2SOCKS -d ${socks5_remote} -j RETURN
    # Reserved port 4000 for testing
    iptables -t mangle -A TUN2SOCKS -d ${socks5_remote} -p tcp ! --dport 4000 -j RETURN
    iptables -t mangle -A TUN2SOCKS -d ${socks5_remote} -p udp ! --dport 4000 -j RETURN
    iptables -t mangle -A TUN2SOCKS -m set --match-set chnroute dst -j RETURN
    iptables -t mangle -A TUN2SOCKS -j MARK --set-mark ${iptables_mark}

    iptables -t mangle -A OUTPUT -p tcp -j TUN2SOCKS
    iptables -t mangle -A OUTPUT -p udp -j TUN2SOCKS

    for intranet in "${iptables_intranet[@]}"; do
        iptables -t mangle -A PREROUTING -p udp -s $intranet ! -d $intranet --dport 53 -j ACCEPT
        iptables -t nat -A PREROUTING -p udp -s $intranet ! -d $intranet --dport 53 -j REDIRECT --to-ports 53

        iptables -t mangle -A PREROUTING -p tcp -s $intranet -j TUN2SOCKS
        iptables -t mangle -A PREROUTING -p udp -s $intranet -j TUN2SOCKS

        iptables -t nat -A POSTROUTING -s $intranet ! -d $intranet -j MASQUERADE
    done
}
function ipts_origin() {
    iptables -t mangle -F OUTPUT
    iptables -t mangle -F PREROUTING
    iptables -t mangle -F TUN2SOCKS &> /dev/null
    iptables -t mangle -X TUN2SOCKS &> /dev/null
    iptables -t nat -F PREROUTING
    iptables -t nat -F POSTROUTING

#    for intranet in "${iptables_intranet[@]}"; do
#        iptables -t nat -A PREROUTING -p udp -s $intranet -d $intranet --dport 53 -j DNAT --to-destination ${dns_original[0]}
#        iptables -t nat -A POSTROUTING -s $intranet ! -d $intranet -j MASQUERADE
#    done
}

function pbr_add() {
    ip route add 0/0 via ${tun2socks_gateway} dev ${tun2socks_tundev} table ${pbr_table}
    ip rule add fwmark ${iptables_mark} table ${pbr_table}
}
function pbr_del() {
    ip rule show | grep "fwmark ${iptables_mark}" | awk -F':' '{print $1}' | xargs -n1 ip rule del pref &> /dev/null
    ip route flush table ${pbr_table}
}

function kernel_opts() {
    if [ $(cat /proc/sys/net/ipv4/ip_forward) -ne 1 ]; then
        echo 1 > /proc/sys/net/ipv4/ip_forward
    fi
    if [ $(cat /proc/sys/net/ipv4/conf/$tun2socks_tundev/rp_filter) -ne 2 ]; then
        echo 2 > /proc/sys/net/ipv4/conf/$tun2socks_tundev/rp_filter
    fi
}

function dns_update() {
    echo "# Generated by ss-tun2socks at $(date '+%F %T')" > /etc/resolv.conf
    #echo "nameserver 127.0.0.1" >> /etc/resolv.conf
    # 127.0.0.53 for ubuntu 18.04 lts
    echo "nameserver 127.0.0.53" >> /etc/resolv.conf
}
function dns_origin() {
#    echo "# Generated by ss-tun2socks at $(date '+%F %T')" > /etc/resolv.conf
#    for dns in "${dns_original[@]}"; do
#        echo "nameserver $dns" >> /etc/resolv.conf
#    done
    systemctl restart NetworkManager
}

function current_ip() {
    ip_info=$(curl -4skL ip.chinaz.com/getip.aspx | sed -r "s/^\{ip:'(.*)',address:'(.*)'\}$/\1|\2/g")
    my_ip=$(echo ${ip_info} | awk -F'|' '{print $1}')
    my_loc=$(echo ${ip_info} | awk -F'|' '{print $2}')
    echo -e "\e[37mIP:\e[0m ${my_ip}\t\e[37mLocation:\e[0m ${my_loc}"
}

function start() {
    dns_origin

    if [ ! -e ${dns_chnroute} ]; then
        echo -e "\e[37m${dns_chnroute}\e[0m  [\e[1;35mnot_exist\e[0m]"
        exit 1
    fi

    eval "${tinymapper_runcmd}"
    eval "${udp2raw_runcmd}"
    eval "${speederv2_runcmd}"

    eval "${socks5_runcmd}"

    nohup tun2socks -tun-device $tun2socks_tundev -tun-address $tun2socks_address -tun-mask $tun2socks_netmask -tun-gw $tun2socks_gateway -local-socks-addr $socks5_listen -public-only < /dev/null &>> $tun2socks_log &

    ipset -X chnroute &> /dev/null
    ipset -R < ${ipset_save_file}

    ipts_update
    pbr_add
    kernel_opts

    dns_update
}

function stop() {
    port=$(echo $socks5_listen | awk -F: '{print $2}')
    ss -lnptu | grep :$port | grep -Eo 'pid=[0-9]+' | awk -F= '{print $2}' | sort -n | uniq | xargs kill &> /dev/null

    pkill '^tun2socks$'

    pkill '^tinymapper$'
    pkill '^speederv2$'
    pkill '^udp2raw$'

    ipts_origin
    ipset -X chnroute &> /dev/null
    pbr_del

    dns_origin
}

function status() {
    if [ $(pgrep -c '^tun2socks$') -ge 1 ]; then
        echo -e "\e[37mtun2socks\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mtun2socks\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    port=$(echo $socks5_listen | awk -F: '{print $2}')

    if [ $(ss -lnpt | grep :$port | wc -l) -ne 0 ]; then
        echo -e "\e[37msocks5/tcp\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37msocks5/tcp\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(ss -lnpu | grep :$port | wc -l) -ne 0 ]; then
        echo -e "\e[37msocks5/udp\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37msocks5/udp\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(pgrep -c '^tinymapper$') -ge 1 ]; then
        echo -e "\e[37mtinymapper\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mtinymapper\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(pgrep -c '^speederv2$') -ge 1 ]; then
        echo -e "\e[37mspeederv2\e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mspeederv2\e[0m\t[\e[1;35mstopped\e[0m]"
    fi

    if [ $(pgrep -c '^udp2raw$') -ge 1 ]; then
        echo -e "\e[37mudp2raw \e[0m\t[\e[1;32mrunning\e[0m]"
    else
        echo -e "\e[37mudp2raw \e[0m\t[\e[1;35mstopped\e[0m]"
    fi
}

function usage() {
    echo -e "\e[37mUsage:\e[0m \e[36m${0}\e[0m \e[1;37mCOMMAND\e[0m"
    echo -e "\e[1;37mCOMMAND\e[0m := {"
    echo -e "\t\e[33mstart\e[0m\t\tstart ss-tun2socks"
    echo -e "\t\e[33mstop\e[0m\t\tstop ss-tun2socks"
    echo -e "\t\e[33mrestart\e[0m\t\trestart ss-tun2socks"
    echo -e "\t\e[33mstatus\e[0m\t\tstatus of ss-tun2socks"
    echo -e "\t\e[33mcurrent_ip\e[0m\tget current ipaddr info"
    echo -e "\t\e[33mupdate_chnip\e[0m\tupdate chnroute for ipset/chinadns"
    echo -e "}"
}

case $1 in
star*)  # start
    start
    status
    ;;
stat*)  # status
    status
    ;;
sto*)   # stop
    stop
    status
    ;;
r*)     # restart
    stop
    status
    echo
    start
    status
    ;;

c*)     # current_ip
    current_ip
    ;;
u*)     # update_chnip
    chnip_update
    ;;

h*)     # help
    usage
    ;;
*)
    usage 1>&2
    exit 1
    ;;
esac
```

ss-tun2socks.conf 配置文件如下

```
## socks5 配置
socks5_listen="127.0.0.1:1080"  # ss本地监听地址
socks5_remote="**.**.**.**"  # ss远程地址
socks5_remote_port="7788"  # ss远程端口
udp2raw_remote_port="4020"  # udp2raw远程端口
#socks5_runcmd="nohup ss-local -c /etc/ss-local.json < /dev/null &>> /var/log/ss-local.log &" # 启动命令

socks5_runcmd="nohup ss-local -s 127.0.0.1 -p 6010 -b 127.0.0.1 -l 1080 -k '******' -m aes-256-gcm -u --fast-open < /dev/null &>> /var/log/ss-local.log &" # 启动命令

tinymapper_runcmd="nohup tinymapper -l0.0.0.0:6010 -r$socks5_remote:$socks5_remote_port -t > /var/log/tinymapper.log 2>&1 &"

udp2raw_runcmd="nohup udp2raw -c -l0.0.0.0:4021 -r$socks5_remote:$udp2raw_remote_port -a -k "passwd" --raw-mode faketcp --cipher-mode xor > /var/log/udp2raw_udp.log 2>&1 &"

speederv2_runcmd="nohup speederv2 -c -l0.0.0.0:6010 -r127.0.0.1:4021 -k "passwd" -f20:10 --mode 0 -i 20 --timeout 20 --report 20 > /var/log/speederv2.log 2>&1 &"

## tun2socks 配置
tun2socks_tundev="tun0"                 # tun 网卡
tun2socks_address="10.0.0.1"            # 接口地址
tun2socks_gateway="10.0.0.254"          # 网关地址
tun2socks_netmask="255.255.255.0"       # 网络掩码
tun2socks_log='/var/log/tun2socks.log'  # 日志文件

## ipset 配置
ipset_save_file='/etc/tun2socks/chnroute.ipset' # chnip列表文件
dns_chnroute='/etc/tun2socks/chnroute.txt' # 大陆地址段列表

## iptables 配置
iptables_mark='0x2333/0x2333'       # mangle mark
iptables_intranet=(192.168.0.0/16)  # 内网网段，多个空格隔开

## pbr 配置
pbr_table=100   # 路由表-表号

## dns 配置
dns_original=(**.**.**.** 119.29.29.29 180.76.76.76) # 正常网络的 DNS，最多 3 个，**.**.**.**替换成本地ISP提供的DNS
```

## overture

下载overture，项目地址

[https://github.com/shawn1m/overture](https://github.com/shawn1m/overture)

在Releases页面下载最新版本overture-linux-amd64.zip

解压到overture目录

```sh
unzip ./overture-linux-amd64.zip -d ./overture
cd overture
```

下载最新的`china_ip_list.txt`和`gfwlist.txt`

```sh
wget -c -N https://raw.githubusercontent.com/17mon/china_ip_list/master/china_ip_list.txt
wget -c -N https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt
```

修改配置文件config.json

```sh
vim ./config.json
```

主DNS列表中添加以下两个DNS，并设置cache和ttl

1. 本地运营商自动分配的DNS
2. 阿里DNS

```
{
  "BindAddress": ":53",
  "PrimaryDNS": [
    {
      "Name": "Auto",
      "Address": "xx.xx.xx.xx:53",
      "Protocol": "udp",
      "SOCKS5Address": "",
      "Timeout": 6,
      "EDNSClientSubnet": {
        "Policy": "disable",
        "ExternalIP": ""
      }
    },
    {
      "Name": "DNSPod",
      "Address": "119.29.29.29:53",
      "Protocol": "udp",
      "SOCKS5Address": "",
      "Timeout": 6,
      "EDNSClientSubnet": {
        "Policy": "disable",
        "ExternalIP": ""
      }
    },
    {
      "Name": "AliDNS",
      "Address": "223.5.5.5:53",
      "Protocol": "udp",
      "SOCKS5Address": "",
      "Timeout": 6,
      "EDNSClientSubnet": {
        "Policy": "disable",
        "ExternalIP": ""
      }
    }
  ],
  "AlternativeDNS": [
    {
      "Name": "OpenDNS",
      "Address": "208.67.222.222:443",
      "Protocol": "tcp",
      "SOCKS5Address": "",
      "Timeout": 6,
      "EDNSClientSubnet": {
        "Policy": "disable",
        "ExternalIP": ""
      }
    }
  ],
  "OnlyPrimaryDNS": false,
  "RedirectIPv6Record": false,
  "IPNetworkFile": "/etc/overture/china_ip_list.txt",
  "DomainFile": "/etc/overture/gfwlist.txt",
  "DomainBase64Decode": true,
  "HostsFile": "/etc/overture/hosts_sample",
  "MinimumTTL": 86400,
  "CacheSize" : 604800,
  "RejectQtype": [255]
}
```

新建install.sh脚本，用于安装overture

```sh
#!/bin/sh

# 复制程序到/usr/bin下
sudo cp -af ./overture-linux-amd64 /usr/local/bin/overture
sudo chown root:root /usr/local/bin/overture
sudo chmod +x /usr/local/bin/overture

# 复制配置文件到/etc/overture下
sudo rsync -r --delete --exclude="overture-linux-amd64" --exclude="domain_sample" --exclude="ip_network_sample" --exclude="install.sh" ./ /etc/overture

# 配置overture服务
sudo bash -c 'cat > /lib/systemd/system/overture.service' << EOF
[Unit]
Description=overture service

[Service]
ExecStart=/usr/local/bin/overture -c /etc/overture/config.json -l /etc/overture/overture.log
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
EOF

# 重载修改过的配置文件
sudo systemctl daemon-reload
```

安装

```sh
./install.sh
```

Ubuntu 18.04 LTS 默认使用systemd-resolved进行dns解析，停掉该服务，再启动overture

停止systemd-resolved

```sh
sudo systemctl stop systemd-resolved
sudo systemctl disable systemd-resolved
```

更改resolv.conf符号连接

```sh
sudo mv /etc/resolv.conf /etc/resolv.conf.bak
sudo ln -s /var/run/NetworkManager/resolv.conf /etc/resolv.conf
```

修改网络连接中的DNS服务器为127.0.0.53

一些软件依赖于NetworkManage或/etc/resolv.conf中的域名服务器才能正常工作，所以我们要把所有DNS的请求接口修改为127.0.0.53:53

重启NetworkManager

```sh
sudo systemctl restart NetworkManager
```

启动overture前，检查53端口是否被占用

```sh
sudo lsof -i:53
```

如果被占用，就杀掉进程(一般被dnsmasq之类的DNS服务占用)

```sh
sudo kill -9 <PID>
```

激活开机启动

```sh
sudo systemctl enable overture
```

启动overture服务

```sh
sudo systemctl start overture
```

检查运行状态

```sh
sudo systemctl status overture
```

至此，默认DNS服务由overture提供

# 局部代理

有了全局智能代理，没必要使用局部代理，这里只是记录一下，需shadowsocks配合

apt-get使用代理

```sh
vim apt_proxy_conf
```

添加

```
Acquire::http::proxy "http://127.0.0.1:1080/";
Acquire::ftp::proxy "ftp://127.0.0.1:1080/";
Acquire::https::proxy "https://127.0.0.1:1080/";
```

更新时使用配置代理

```sh
sudo apt-get update -c apt_proxy_conf
```

proxychain5代理

```sh
sudo apt-get install proxychains
```

配置

```sh
sudo vim /etc/proxychains.conf
```

添加

```
socks5  127.0.0.1 1080
```

# 安装Chrome

```sh
sudo apt-get install gdebi
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
sudo gdebi google-chrome-stable_current_amd64.deb
```

# 安装Redshift

Ubuntu 18.04 LTS 已经集成了夜灯模式，位于 设置-设备-显示-夜灯

Redshift作为备选，有特殊需求可以安装

```sh
sudo apt-get install redshift-gtk
```

Redshift项目地址

[https://github.com/jonls/redshift](https://github.com/jonls/redshift)

下载配置文件redshift.conf，放到如下目录

```
~/.config/redshift.conf
```

修改几个主要参数

```
; Set the day and night screen temperatures
temp-day=4300
temp-night=3300

; Disable the smooth fade between temperatures when Redshift starts and stops.
; 0 will cause an immediate change between screen temperatures.
; 1 will gradually apply the new screen temperature over a couple of seconds.
fade=0

[manual]
lat=22.5
lon=114.0
```

运行，在托盘图标勾选Autostart

# 安装Dropbox

下载最新的Stable版本包，解压到~/.dropbox-dist目录下

```sh
wget https://clientupdates.dropboxstatic.com/dbx-releng/client/dropbox-lnx.x86_64-48.4.58.tar.gz

tar -zxvf dropbox-lnx.x86_64-48.4.58.tar.gz
```

新建dropbox.servive

```
[Unit]
Description=Dropbox as a user service
After=local-fs.target network.target

[Service]
Type=simple
ExecStart=%h/.dropbox-dist/dropboxd
Restart=on-failure
RestartSec=1
# Note: don't set these in user mode- they're already set, and
# systemd won't have permission to set them- killing your service before
# it starts
# User=%U
# Group=%U

[Install]
WantedBy=default.target
```

把dropbox.service移动到用户服务目录下

```sh
mkdir -p ~/.config/systemd/user
mv ~/dropbox.service ~/.config/systemd/user/
```

重载服务

```sh
systemctl --user daemon-reload
```

开机自动启动服务

```sh
systemctl --user enable dropbox
```

启动服务

```sh
systemctl --user start dropbox
```

# 安装Jekyll

安装ruby开发包

```sh
sudo apt-get install ruby ruby-dev
```

安装jekyll和bundler

```sh
sudo gem install jekyll bundler
```

进入Gemfile所在目录，更新依赖

```sh
bundle install
```

或者安装gem包到指定目录，以隔离对系统gem的影响

```sh
bundle install --path vendor/bundle
```

过程可能会报错，我的具体情况是 nokogiri 依赖 zlib

```sh
sudo apt-get install zlib1g-dev
```

启动本地服务

```sh
bundle exec jekyll serve --baseurl=""
```

# 安装Virtualbox

```sh
sudo apt install virtualbox
```

安装扩展，可选

```sh
sudo apt install virtualbox-ext-pack
```

# 安装Docker

确保APT能使用https方式工作，并且CA证书已安装

```sh
sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
```

添加官方GPG密钥

```sh
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```

添加REPO并更新

```sh
echo "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list
```

或者直接追加进sources.list中

```sh
sudo add-apt-repository \
"deb [arch=amd64] https://download.docker.com/linux/ubuntu \
$(lsb_release -cs) \
stable"
```

更新

```sh
sudo apt-get update
```

安装docker-ce

```sh
sudo apt-get install docker-ce
```

Docker Hub加速

```sh
sudo vim /etc/docker/daemon.json
```

添加镜像加速地址

```
{
    "registry-mirrors": ["https://40fcvoar.mirror.aliyuncs.com"]
}
```

重启docker服务

```sh
sudo service docker restart
```

安装docker-machine

```sh
curl -L https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname -s`-`uname -m` >/tmp/docker-machine && chmod +x /tmp/docker-machine && sudo cp /tmp/docker-machine /usr/local/bin/docker-machine
```


# 系统备份 & 还原

安装pigz多线程压缩

```sh
sudo apt-get install pigz
```

备份

备份文件所存放的位置，根据实际情况更改

```sh
BACKUP_FILE_PATH=/media/howie/F63E9E535BFBE2AE/Ubuntu
```

备份软件包

```sh
sudo cp -r /var/cache/apt/archives/* $BACKUP_FILE_PATH/archives/
```

执行备份

```sh
sudo tar --use-compress-program=pigz -cvpf $BACKUP_FILE_PATH/ubuntu.tar.gz \
--exclude=/proc \
--exclude=/tmp \
--exclude=/mnt \
--exclude=/dev \
--exclude=/sys \
--exclude=/run \
--exclude=/media \
--exclude=/var/log \
--exclude=/var/cache/apt/archives \
--exclude=/usr/src/linux-headers* \
--exclude=/home/*/.gvfs \
--exclude=/home/*/.cache \
--exclude=/home/*/.local/share/Trash \
--exclude=/cdrom \
--exclude=/lost+found \
--exclude=/swapfile \
--exclude=/root/.cache \
--exclude=/var/tmp \
/ > $BACKUP_FILE_PATH/ubuntu.log 2>&1
```

还原

通过live cd进入试用ubuntu

备份文件所存放的位置，根据实际情况更改

```sh
BACKUP_FILE_PATH=/media/ubuntu/F63E9E535BFBE2AE/Ubuntu
```

查看分区情况

```sh
lsblk
```

挂载备份文件所在分区，一般会自动挂载在media下，自行查看

```sh
sudo mount /dev/nvme0n1p5 /mnt
```

删除旧系统所有数据

```sh
sudo rm -rf /mnt/*
```

挂载UEFI分区

```sh
sudo mkdir -p /mnt/boot/efi
sudo mount /dev/nvme0n1p1 /mnt/boot/efi
```

恢复

```sh
sudo tar -zxvpf $BACKUP_FILE_PATH/ubuntu.tar.gz -C /mnt --numeric-owner
```

新建目录

```sh
cd /mnt
sudo mkdir -p proc sys dev run mnt tmp var/log var/cache/apt/archives
```

复制软件包

```sh
sudo cp -r $BACKUP_FILE_PATH/archives/* /var/cache/apt/archives/
```

修复grub2引导

通过live cd进入试用ubuntu

挂载安装的Linux分区

```sh
sudo mount /dev/nvme0n1p5 /mnt
```

挂载EFI分区

```sh
sudo mount /dev/nvme0n1p1 /mnt/boot/efi
for i in /dev /dev/pts /proc /sys /run; do sudo mount -B $i /mnt$i; done
```

chroot到安装的Linux

```sh
sudo chroot /mnt
```

重装grub-efi

```sh
apt-get install --reinstall grub-efi
```

安装grub2到UEFI分区所在的硬盘上

```sh
grub-install /dev/nvme0n1
```

更新grub配置

```sh
update-grub
```
